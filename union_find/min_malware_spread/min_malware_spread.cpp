#include <vector>
#include <unordered_map>
using namespace std;

class MinMalwareSpread
{ // LeetCode Q.924.
private:
    vector<int> parents;

    int find_parent(int node)
    {
        if (node == parents[node])
        {
            return node;
        }
        return find_parent(parents[node]);
    }

    void union_nodes(int node_1, int node_2)
    {
        int node_1_parent = find_parent(node_1);
        int node_2_parent = find_parent(node_2);
        parents[node_2_parent] = node_1_parent;
    }

public:
    int minMalwareSpread(vector<vector<int>> &graph, vector<int> &infected_nodes)
    {
        int total_nodes = graph.size();
        for (int node = 0; node < total_nodes; node++)
        {
            parents.push_back(node);
        }
        for (int node_1 = 0; node_1 < total_nodes; node_1++)
        {
            for (int node_2 = node_1 + 1; node_2 < total_nodes; node_2++)
            {
                if (graph[node_1][node_2] == 1)
                { // Connected nodes.
                    union_nodes(node_1, node_2);
                }
            }
        }

        // Group malware nodes by parents.
        unordered_map<int, vector<int>> malware_nodes_groups;
        for (auto malware_node : infected_nodes)
        {
            int parent = find_parent(malware_node);
            if (malware_nodes_groups.find(parent) == malware_nodes_groups.end())
            {
                malware_nodes_groups[parent] = {};
            }
            malware_nodes_groups[parent].push_back(malware_node);
        }

        vector<int> candidate_nodes;
        for (const auto &pair : malware_nodes_groups)
        {
            // A candidate's parent must have just 1 malware node.
            if (pair.second.size() == 1)
            {
                candidate_nodes.push_back(pair.second[0]);
            }
        }
        if (candidate_nodes.empty())
        {
            return *min_element(infected_nodes.begin(), infected_nodes.end());
        }

        int max_reduction = 0;
        int removal_node = total_nodes - 1;

        unordered_map<int, int> parents2sizes; // Group all nodes by parents.
        for (int node = 0; node < total_nodes; node++)
        {
            int parent = find_parent(node);
            if (parents2sizes.find(parent) == parents2sizes.end())
            {
                parents2sizes[parent] = 0;
            }
            parents2sizes[parent] += 1;
        }

        for (auto candidate : candidate_nodes)
        {
            int parent = find_parent(candidate);
            if (parents2sizes[parent] > max_reduction)
            {
                max_reduction = parents2sizes[parent];
                removal_node = candidate;
            }
            if (parents2sizes[parent] == max_reduction)
            {
                if (candidate < removal_node)
                {
                    removal_node = candidate; // Pick smallest node of same reduction.
                }
            }
        }

        return removal_node;
    }
};